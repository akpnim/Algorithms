Python implementation of algorithms covered in the algorithms specialisation. These include:<br>  

(1) Karatsuba Multiplication [MergeSort]<br>
(2) Inversion Count [MergeSort]<br>
(3) QuickSort using first element as the pivot<br>
(4) QuickSort using last element as the pivot<br>
(5) QuickSort using a median of the first, last and median element as the pivot<br>
(6) Random Contraction Algorithm - computing the minimum cut of a graph <br>
(7) Kosaraju's Algorithm for strongly connected components (SCC) of a directed graph [CHALLENGING] <br>
(8) Dijkstra's Algorithm in O(m*n) i.e. the regular approach. (not heap based)<br>
(9) Median maintenance - using two Heaps to maintain the median of an incoming stream of numbers. <br>
(10) Two sum variation - hash table not necessary but could have been used. <br>
(11) Greedy by difference - greedy algorithm that prioritizes by decreasing difference (weight - lengths). <br>
(12) Greedy by ratio - optimal greedy algorithm that prioritizes by decreasing ratio (weight/length). <br> 
(13) Primm's Algorithm for minimum spanning tree [non-heap based]. <br> 
(14) Primm's Algorithm for minimum spanning tree [heap-based superfast!]. <br>
(15) Kruskal's Algorithm applied via Union-Find to find max-spacing of a k-clustering. <br>
(16) Kruskal's Algorithm applied via Union-Find to find max-clustering for a given hamming distance spacing for a large graph. [CHALLENGING] <br> 
(17) Huffman Code - min and max bit-length finder using a custom binary tree + heap. <br> 
(18) Dynamic Programming - Maximum weight independent set of a path graph <br> 
(19) Dynamic - Knapsack - Iterative version <br>
(20) Dynamic - Knapsack - Recursive version with caching to handle a large number of items/weight capacity <br> 
.. to be continued
